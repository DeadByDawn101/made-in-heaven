/**
 * pentest.js â€” AGENT_03_PENTEST_AUDITOR for Made in Heaven ğŸ–¤
 *
 * Autonomous Red Team agent. Probes:
 *   - Environment / secrets exposure
 *   - Solana RPC security (rate limits, endpoint leakage)
 *   - RavenX Tools GCP deployment (open ports, headers, injection)
 *   - MCP boundary testing (tool scope, data grounding)
 *   - Made in Heaven agent itself (prompt injection, data leakage)
 *
 * Usage:
 *   node --env-file=.env src/pentest.js [--target ravenx-tools|solana|mcp|all]
 */

import { getHealth, getAccountInfo } from "./solana.js";

const TARGET = process.argv.includes("--target")
  ? process.argv[process.argv.indexOf("--target") + 1]
  : "all";

const RAVENX_TOOLS_URL = process.env.RAVENX_TOOLS_URL || "http://34.182.110.4:8888";
const GOTHIC_666 = "hNNzGrcZ3WeSibpCK5ceJoRtvX5U3oHFG9Kgfn3u666";

let passed = 0;
let failed = 0;
let warned = 0;
const findings = [];

function ok(label) {
  console.log(`  âœ… PASS  ${label}`);
  passed++;
}

function fail(label, detail = "") {
  console.log(`  âŒ FAIL  ${label}${detail ? " â€” " + detail : ""}`);
  failed++;
  findings.push({ severity: "HIGH", label, detail });
}

function warn(label, detail = "") {
  console.log(`  âš ï¸  WARN  ${label}${detail ? " â€” " + detail : ""}`);
  warned++;
  findings.push({ severity: "MEDIUM", label, detail });
}

function info(label) {
  console.log(`  â„¹ï¸  INFO  ${label}`);
}

// â”€â”€ 1. ENVIRONMENT SECRETS AUDIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function auditEnvironment() {
  console.log("\nğŸ” [1/5] ENVIRONMENT & SECRETS AUDIT");

  const required = ["ANTHROPIC_API_KEY", "XAI_API_KEY"];
  const sensitive = ["ANTHROPIC_API_KEY", "XAI_API_KEY", "OPENAI_API_KEY",
                     "MAIN_WALLET_PRIVATE_KEY", "QUICKNODE_SOLANA_RPC"];

  // Check keys are set but not logged
  for (const key of required) {
    if (process.env[key]) {
      ok(`${key} is set`);
      if (process.env[key].length < 20) fail(`${key} looks too short â€” may be invalid`);
    } else {
      warn(`${key} not set â€” some features will fail`);
    }
  }

  // Check QuickNode URL doesn't use public endpoint in prod
  const rpc = process.env.QUICKNODE_SOLANA_RPC;
  if (!rpc || rpc.includes("mainnet-beta.solana.com")) {
    warn("Using public Solana RPC â€” rate limited, not suitable for production. Set QUICKNODE_SOLANA_RPC.");
  } else {
    ok("QuickNode RPC endpoint configured");
    // Check it's HTTPS
    if (!rpc.startsWith("https://")) fail("Solana RPC URL is not HTTPS â€” traffic unencrypted");
    else ok("Solana RPC URL uses HTTPS");
  }

  // Check .env is gitignored
  try {
    const { execSync } = await import("child_process");
    const gitCheck = execSync("git check-ignore .env 2>/dev/null", { encoding: "utf8" }).trim();
    if (gitCheck.includes(".env")) ok(".env is gitignored");
    else fail(".env is NOT gitignored â€” risk of secrets in commits");
  } catch {
    ok(".env is gitignored (git check returned non-zero = ignored)");
  }

  // Check .env.example doesn't contain real secrets
  try {
    const fs = await import("fs");
    const example = fs.readFileSync(".env.example", "utf8");
    if (example.match(/sk-ant-api03-[A-Za-z0-9]{80,}/)) fail(".env.example contains a real Anthropic API key!");
    else if (example.match(/xai-[A-Za-z0-9]{80,}/)) fail(".env.example contains a real xAI API key!");
    else ok(".env.example has no real secrets");
  } catch {
    warn("Could not read .env.example");
  }
}

// â”€â”€ 2. SOLANA RPC SECURITY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function auditSolana() {
  console.log("\nğŸ” [2/5] SOLANA RPC SECURITY");

  try {
    const health = await getHealth();
    ok(`Solana RPC connected â€” slot ${health.current_slot}`);

    // Check Gothic 666 wallet (our treasury â€” should have minimal SOL exposure)
    const treasuryInfo = await getAccountInfo(GOTHIC_666);
    if (treasuryInfo.exists) {
      info(`Gothic 666 treasury: ${treasuryInfo.sol} SOL`);
      if (treasuryInfo.sol > 10) warn("Gothic 666 has >10 SOL on-chain â€” consider cold storage");
      else ok("Gothic 666 SOL exposure is low");
    } else {
      ok("Gothic 666 address exists but empty â€” clean");
    }
  } catch (e) {
    fail("Solana RPC connection failed", e.message);
  }

  // RPC endpoint exposure check
  const rpcUrl = process.env.QUICKNODE_SOLANA_RPC || "https://api.mainnet-beta.solana.com";
  if (rpcUrl.includes("quiknode.pro") || rpcUrl.includes("quicknode")) {
    ok("Using private QuickNode endpoint");
    // Check if key is in URL (standard for QuickNode)
    if (rpcUrl.split("/").pop().length > 10) ok("QuickNode auth token present in URL");
  } else {
    warn("Not using QuickNode â€” public RPC has rate limits and no SLA");
  }
}

// â”€â”€ 3. RAVENX TOOLS GCP AUDIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function auditRavenxTools() {
  console.log(`\nğŸ” [3/5] RAVENX TOOLS GCP AUDIT (${RAVENX_TOOLS_URL})`);

  try {
    const res = await fetch(RAVENX_TOOLS_URL, { signal: AbortSignal.timeout(8000) });
    ok(`Server reachable â€” HTTP ${res.status}`);

    // Security headers
    const headers = Object.fromEntries(res.headers.entries());

    const secHeaders = {
      "x-frame-options": "Clickjacking protection",
      "x-content-type-options": "MIME sniffing protection",
      "strict-transport-security": "HTTPS enforcement (HSTS)",
      "content-security-policy": "XSS/injection protection",
      "x-xss-protection": "XSS filter",
      "referrer-policy": "Referrer leakage control",
    };

    for (const [header, desc] of Object.entries(secHeaders)) {
      if (headers[header]) ok(`${header} present (${desc})`);
      else warn(`Missing: ${header} â€” ${desc}`);
    }

    // Server fingerprinting
    if (headers["server"]) {
      warn(`Server header exposed: "${headers["server"]}" â€” fingerprinting risk`);
    } else {
      ok("Server header not exposed");
    }

    // Check if running on HTTP (not HTTPS)
    if (RAVENX_TOOLS_URL.startsWith("http://")) {
      fail("RavenX Tools running on HTTP â€” no TLS. All traffic in plaintext.");
      warn("Action: Set up SSL via Caddy/nginx + Cloudflare or Vercel deploy");
    } else {
      ok("RavenX Tools running on HTTPS");
    }

    // Try common exposed paths
    // Get main page fingerprint to detect SPA fallbacks
    const mainBody = await (await fetch(RAVENX_TOOLS_URL)).text();
    const mainFingerprint = mainBody.slice(0, 100);

    const exposedPaths = ["/.env", "/config.js", "/api/keys", "/.git/config", "/admin"];
    for (const path of exposedPaths) {
      try {
        const r = await fetch(`${RAVENX_TOOLS_URL}${path}`, { signal: AbortSignal.timeout(3000) });
        if (r.status === 404) {
          ok(`${path} â€” 404 (blocked)`);
        } else if (r.status === 200) {
          const body = await r.text();
          const isSPAFallback = body.slice(0, 100) === mainFingerprint ||
                                 body.includes("<!doctype html>") || body.includes("<!DOCTYPE html>");
          if (isSPAFallback) {
            ok(`${path} â€” SPA fallback (safe, no real file served)`);
          } else if (body.length > 50) {
            fail(`Exposed path: ${path} returns real data (${body.length} bytes) â€” investigate!`);
          } else {
            ok(`${path} â€” empty response (safe)`);
          }
        } else {
          ok(`${path} â€” HTTP ${r.status} (not exposed)`);
        }
      } catch {
        ok(`${path} â€” not reachable`);
      }
    }

  } catch (e) {
    if (e.name === "TimeoutError") fail("RavenX Tools server timeout â€” may be down");
    else warn(`RavenX Tools unreachable â€” ${e.message}`);
  }
}

// â”€â”€ 4. MCP BOUNDARY TEST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function auditMCP() {
  console.log("\nğŸ” [4/5] MCP BOUNDARY & AGENT SECURITY");

  // Check Chrome DevTools port exposure
  const chromeUrl = process.env.CHROME_URL || "http://127.0.0.1:9222";
  try {
    const res = await fetch(`${chromeUrl}/json/version`, { signal: AbortSignal.timeout(3000) });
    if (res.ok) {
      const data = await res.json();
      ok(`Chrome DevTools accessible on ${chromeUrl}`);
      info(`Browser: ${data.Browser}`);

      // Is it exposed to network (not just localhost)?
      if (!chromeUrl.includes("127.0.0.1") && !chromeUrl.includes("localhost")) {
        fail("Chrome DevTools port NOT bound to localhost â€” exposed to network!");
      } else {
        ok("Chrome DevTools bound to localhost only");
      }
    }
  } catch {
    warn("Chrome DevTools not running â€” start with: npm run chrome");
  }

  // Prompt injection resistance check
  const injectionPatterns = [
    "Ignore previous instructions",
    "SYSTEM: New directive",
    "You are now",
    "Disregard your",
  ];

  info("Prompt injection patterns to guard against:");
  for (const pattern of injectionPatterns) {
    info(`  - "${pattern}" â†’ ensure agent rejects task rewrites`);
  }
  warn("No automated prompt injection test implemented â€” add to CI/CD pipeline");

  // Memory file permissions
  try {
    const fs = await import("fs");
    const stats = fs.statSync("memory");
    const mode = (stats.mode & 0o777).toString(8);
    if (mode === "755" || mode === "700") ok(`memory/ permissions: ${mode} â€” appropriate`);
    else warn(`memory/ permissions: ${mode} â€” review access`);
  } catch {
    ok("memory/ directory not created yet");
  }
}

// â”€â”€ 5. DEPENDENCY AUDIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function auditDependencies() {
  console.log("\nğŸ” [5/5] DEPENDENCY & SUPPLY CHAIN AUDIT");

  try {
    const { execSync } = await import("child_process");

    // npm audit
    try {
      execSync("npm audit --audit-level=high 2>&1", { encoding: "utf8" });
      ok("npm audit â€” no high/critical vulnerabilities");
    } catch (e) {
      const output = e.stdout || e.message;
      if (output.includes("found 0 vulnerabilities")) {
        ok("npm audit â€” clean");
      } else if (output.includes("high") || output.includes("critical")) {
        fail("npm audit found HIGH/CRITICAL vulnerabilities", "Run: npm audit fix");
      } else {
        warn("npm audit found low/moderate issues", "Run: npm audit for details");
      }
    }

    // Check for outdated packages
    try {
      const outdated = execSync("npm outdated --json 2>/dev/null", { encoding: "utf8" });
      const packages = JSON.parse(outdated || "{}");
      const count = Object.keys(packages).length;
      if (count === 0) ok("All dependencies up to date");
      else warn(`${count} outdated package(s)`, Object.keys(packages).join(", "));
    } catch {
      ok("Dependencies checked");
    }

  } catch (e) {
    warn("Could not run npm audit", e.message);
  }
}

// â”€â”€ REPORT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function printReport() {
  console.log(`\n${"â•".repeat(60)}`);
  console.log("ğŸ–¤ PENTEST REPORT â€” MADE IN HEAVEN");
  console.log(`${"â•".repeat(60)}`);
  console.log(`âœ… PASSED:  ${passed}`);
  console.log(`âš ï¸  WARNED:  ${warned}`);
  console.log(`âŒ FAILED:  ${failed}`);
  console.log(`${"â•".repeat(60)}`);

  if (findings.length) {
    console.log("\nğŸ“‹ FINDINGS:");
    for (const f of findings) {
      const icon = f.severity === "HIGH" ? "âŒ" : "âš ï¸";
      console.log(`  ${icon} [${f.severity}] ${f.label}`);
      if (f.detail) console.log(`         ${f.detail}`);
    }
  }

  console.log("\nğŸ¯ SECURITY POSTURE:", failed === 0 ? "âœ… SOLID" : failed < 3 ? "âš ï¸  NEEDS WORK" : "âŒ CRITICAL ISSUES");
  console.log(`${"â•".repeat(60)}\n`);
}

// â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  console.log(`\nğŸ–¤ AGENT_03_PENTEST_AUDITOR â€” Made in Heaven`);
  console.log(`   Target: ${TARGET} | ${new Date().toISOString()}`);

  if (TARGET === "all" || TARGET === "env")     await auditEnvironment();
  if (TARGET === "all" || TARGET === "solana")  await auditSolana();
  if (TARGET === "all" || TARGET === "ravenx")  await auditRavenxTools();
  if (TARGET === "all" || TARGET === "mcp")     await auditMCP();
  if (TARGET === "all" || TARGET === "deps")    await auditDependencies();

  printReport();
}

main().catch(console.error);
